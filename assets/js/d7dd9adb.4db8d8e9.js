"use strict";(self.webpackChunktrends_in_web_dev_website=self.webpackChunktrends_in_web_dev_website||[]).push([[8956],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return t?a.createElement(h,l(l({ref:n},c),{},{components:t})):a.createElement(h,l({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4794:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return c}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),l=["components"],o={id:"lecture1",title:"Lecture 1"},s=void 0,p={unversionedId:"lecture1",id:"version-2023sp/lecture1",isDocsHomePage:!1,title:"Lecture 1",description:"Homework: None!",source:"@site/versioned_docs/version-2023sp/lecture1.md",sourceDirName:".",slug:"/lecture1",permalink:"/docs/lecture1",tags:[],version:"2023sp",frontMatter:{id:"lecture1",title:"Lecture 1"}},c=[{value:"JavaScript",id:"javascript",children:[{value:"What is JavaScript",id:"what-is-javascript",children:[],level:3},{value:"JavaScript, conceptually.",id:"javascript-conceptually",children:[],level:3},{value:"Basic JavaScript Syntax",id:"basic-javascript-syntax",children:[{value:"Variables",id:"variables",children:[],level:4},{value:"Objects",id:"objects",children:[],level:4},{value:"if statements",id:"if-statements",children:[],level:4},{value:"for loops",id:"for-loops",children:[{value:"regular counter for loop",id:"regular-counter-for-loop",children:[],level:5},{value:"for of loop",id:"for-of-loop",children:[],level:5}],level:4},{value:"for in loop",id:"for-in-loop",children:[],level:4},{value:"while loops",id:"while-loops",children:[],level:4},{value:"function declaration",id:"function-declaration",children:[],level:4},{value:"functions, conceptually",id:"functions-conceptually",children:[{value:"bonus: factory functions and closures",id:"bonus-factory-functions-and-closures",children:[],level:5}],level:4},{value:"the spread operator (JS-specific)",id:"the-spread-operator-js-specific",children:[],level:4},{value:"destructuring (JS-specific)",id:"destructuring-js-specific",children:[],level:4},{value:"String interpolation and template literals (JS-specific)",id:"string-interpolation-and-template-literals-js-specific",children:[],level:4}],level:3},{value:"combining spreading and destructuring",id:"combining-spreading-and-destructuring",children:[],level:3}],level:2},{value:"TypeScript",id:"typescript",children:[{value:"What is TypeScript?",id:"what-is-typescript",children:[],level:3},{value:"TypeScript, conceptually.",id:"typescript-conceptually",children:[],level:3},{value:"TypeScript Types",id:"typescript-types",children:[],level:3},{value:"How are types used?",id:"how-are-types-used",children:[],level:3},{value:"Why TypeScript?",id:"why-typescript",children:[],level:3},{value:"TypeScript Types",id:"typescript-types-1",children:[{value:"Basic Types",id:"basic-types",children:[],level:4},{value:"Any",id:"any",children:[],level:4}],level:3},{value:"Unknown",id:"unknown",children:[{value:"Never",id:"never",children:[],level:4},{value:"Void",id:"void",children:[],level:4},{value:"Functions",id:"functions",children:[],level:4},{value:"Literal Types",id:"literal-types",children:[{value:"String Literal Types",id:"string-literal-types",children:[],level:5},{value:"Numeric Literal Types",id:"numeric-literal-types",children:[],level:5}],level:4},{value:"Union Types",id:"union-types",children:[],level:4},{value:"Intersection Types",id:"intersection-types",children:[],level:4},{value:"Enumerations",id:"enumerations",children:[],level:4},{value:"Interfaces",id:"interfaces",children:[{value:"Bonus Content: Complex Interface Usage",id:"bonus-content-complex-interface-usage",children:[],level:5}],level:4},{value:"Type Assertions",id:"type-assertions",children:[],level:4},{value:"Generics",id:"generics",children:[],level:4}],level:3}],level:2},{value:"Functional Programming",id:"functional-programming",children:[{value:"Control Branching:",id:"control-branching",children:[],level:3},{value:"Functions:",id:"functions-1",children:[],level:3},{value:"<code>map</code>",id:"map",children:[],level:3},{value:"<code>filter</code>",id:"filter",children:[],level:3},{value:"<code>forEach</code>",id:"foreach",children:[],level:3},{value:"<code>every</code>",id:"every",children:[],level:3},{value:"<code>some</code>",id:"some",children:[],level:3},{value:"<code>reduce</code>",id:"reduce",children:[],level:3}],level:2},{value:"Ugly Pieces of JavaScript",id:"ugly-pieces-of-javascript",children:[{value:"Truthy, falsy",id:"truthy-falsy",children:[],level:3},{value:"Global variables",id:"global-variables",children:[],level:3},{value:"Type coercion",id:"type-coercion",children:[{value:"Example 1",id:"example-1",children:[],level:4},{value:"Example 2",id:"example-2",children:[],level:4},{value:"Example 3",id:"example-3",children:[],level:4}],level:3},{value:"In-class Demo 1: Types!",id:"in-class-demo-1-types",children:[],level:3}],level:2}],u={toc:c};function d(e){var n=e.components,t=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Homework: None!"),(0,i.kt)("p",null,"Slides: ",(0,i.kt)("a",{parentName:"p",href:"https://docs.google.com/presentation/d/1BlAPMcTlbvqgjwhDZv3GlOiGQhcY9am-dQTrMaGWbbI/edit?usp=sharing"},"Here")),(0,i.kt)("p",null,"Explore more:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A library for functional ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/gvergnaud/ts-pattern"},"Pattern Matching")," in TypeScript, to make it even easier to write functional code.")),(0,i.kt)("h1",{id:"todays-lecture-220"},"Today's Lecture 2/20"),(0,i.kt)("p",null,"By the end of today, you should be able to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Understand the basics of JavaScript"),(0,i.kt)("li",{parentName:"ul"},"Understand the basics of TypeScript")),(0,i.kt)("h2",{id:"javascript"},"JavaScript"),(0,i.kt)("h3",{id:"what-is-javascript"},"What is JavaScript"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"JavaScript is the de-facto language of the web"),(0,i.kt)("li",{parentName:"ul"},"Commonly used in conjunction with HTML/CSS"),(0,i.kt)("li",{parentName:"ul"},"Became really popular for powering client-side logic through AJAX",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Previously, languages like PHP had to communicate with the server before\ncoming back with a response"))),(0,i.kt)("li",{parentName:"ul"},"These days, JavaScript is everywhere!")),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Java is to JavaScript as car is to carpet. They are very different languages!"))),(0,i.kt)("h3",{id:"javascript-conceptually"},"JavaScript, conceptually."),(0,i.kt)("p",null,"JavaScript is a multi-paradigm language, in that it supports multiple programming styles, including Object-Oriented Programming (OOP) (such as in CS 2110), and Functional Programming (FP) (such as in CS 3110)."),(0,i.kt)("p",null,"JavaScript is a ",(0,i.kt)("strong",{parentName:"p"},"dynamic")," and ",(0,i.kt)("strong",{parentName:"p"},"weakly typed")," language, meaning that it is not statically typed. This means that we don't have to declare the type of a variable before we use it, and the type of a variable can change at runtime. This is in contrast to languages like Java, which are statically typed."),(0,i.kt)("p",null,'The "Trend in Web Development" is to use JavaScript functionally. If you\'re new to functional programming, in essence, we want to avoid mutating state and instead use immutable data structures that are transformed through functions. This is a very powerful paradigm that allows us to write code that is easier to reason about and test. Throughout this class, we\'ll encourage you to write your code functionally (declaratively), though obviously "normal" OOP or imperative programming is also fine.'),(0,i.kt)("h3",{id:"basic-javascript-syntax"},"Basic JavaScript Syntax"),(0,i.kt)("h4",{id:"variables"},"Variables"),(0,i.kt)("p",null,"There are three ways to create variables in JS:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("del",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"del"},"var x = 5"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"let x = 5")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"const x = 5")))),(0,i.kt)("p",null,"We prefer using ",(0,i.kt)("strong",{parentName:"p"},"const")," for declaring non-reassignable variables although let is also accepted.\n",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("strong",{parentName:"em"},"Never use var."))),(0,i.kt)("p",null,"The differences between the three are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"var")," is hoisted, meaning that it is accessible ",(0,i.kt)("em",{parentName:"li"},"before")," it is declared (yes, you read that right). This is\nbad practice and can lead to bugs. There are some cases where you might want to use ",(0,i.kt)("inlineCode",{parentName:"li"},"var"),", but they're beyond the scope of this class."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"let")," is block-scoped, meaning that it is only accessible within the block it is declared in. This is\nthe most common way to declare variables, and is the equivalent of ",(0,i.kt)("inlineCode",{parentName:"li"},"int x = 5")," in Java."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"const")," is block-scoped, and cannot be reassigned. This is the equivalent of ",(0,i.kt)("inlineCode",{parentName:"li"},"final int x = 5")," in Java.\nWe prefer using ",(0,i.kt)("inlineCode",{parentName:"li"},"const")," for declaring non-reassignable variables, as it also enforces immutability and the functional paradigm (easier to debug, test, and reason about).")),(0,i.kt)("p",null,"Now that we've gone over the basics of variables, let's see how we can use them."),(0,i.kt)("h4",{id:"objects"},"Objects"),(0,i.kt)("p",null,"Objects are a collection of key-value pairs. They are similar to dictionaries in Python, or maps in Java."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const person = {\n  name: 'John',\n  age: 30,\n  height: 6.0,\n  isTall: true,\n};\n")),(0,i.kt)("p",null,"You can access the values of an object using the dot operator, which brings up the autocomplete menu."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'console.log(person.name); // "John"\nconsole.log(person.age); // 30\n')),(0,i.kt)("p",null,"You can also access the values of an object using the bracket operator, which lets you compute the key on the fly if needed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"console.log(person['name']); // \"John\"\nconsole.log(person['age']); // 30\n")),(0,i.kt)("p",null,"Objects can also be nested."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const person = {\n  name: 'John',\n  age: 30,\n  height: 6.0,\n  isTall: true,\n  address: {\n    street: '123 Main St',\n    city: 'New York',\n    state: 'NY',\n    zip: 10001,\n  },\n};\n")),(0,i.kt)("p",null,'This is the basis of the "JSON" format, which is a common way to store data. In essence, JSON is just the string representation of a big JavaScript object.'),(0,i.kt)("h4",{id:"if-statements"},"if statements"),(0,i.kt)("p",null,"Nothing surprising here."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"if (condition) {\n  // executes if condition is true\n} else if (condition2) {\n  // executes if condition is false but condition2 is true\n} else {\n  // executes if condition is false\n}\n")),(0,i.kt)("h4",{id:"for-loops"},"for loops"),(0,i.kt)("h5",{id:"regular-counter-for-loop"},"regular counter for loop"),(0,i.kt)("p",null,"This should also look familiar."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"for (let i = 0; i < 5; i++) {\n  console.log(i);\n}\n")),(0,i.kt)("h5",{id:"for-of-loop"},"for of loop"),(0,i.kt)("p",null,"We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"for..of")," loops to loop through elements of an array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const arr = [10, 20, 30, 40];\nfor (const val of arr) {\n  console.log(val); // prints values: 10, 20, 30, 40\n}\n")),(0,i.kt)("h4",{id:"for-in-loop"},"for in loop"),(0,i.kt)("p",null,"We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"for..in")," loops to loop through keys of an object. A good way to remember\nwhen to use ",(0,i.kt)("inlineCode",{parentName:"p"},"of")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"in")," is that ",(0,i.kt)("inlineCode",{parentName:"p"},"of")," is for iterables (such as arrays), while ",(0,i.kt)("inlineCode",{parentName:"p"},"in")," is for objects."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const object = { a: 1, b: 2, c: 3 };\n\nfor (const property in object) {\n  console.log(`${property}: ${object[property]}`);\n}\n\n// expected output:\n// "a: 1"\n// "b: 2"\n// "c: 3"\n')),(0,i.kt)("h4",{id:"while-loops"},"while loops"),(0,i.kt)("p",null,"Not too different from what you're used to."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'let n = 0;\n\nwhile (n < 3) {\n  console.log(n);\n  n++;\n}\n\n// expected output:\n// "0"\n// "1"\n// "2"\n')),(0,i.kt)("h4",{id:"function-declaration"},"function declaration"),(0,i.kt)("p",null,"We can use the function key word to define a function!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function calcRectArea(width, height) {\n  return width * height;\n}\n\nconsole.log(calcRectArea(5, 6)); // 30\n")),(0,i.kt)("p",null,"or we can use ",(0,i.kt)("em",{parentName:"p"},"arrow functions"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const calcRectArea = (width, height) => {\n  return width * height;\n};\n")),(0,i.kt)("p",null,"When the function body is a single expression, we can omit the curly braces and the return keyword."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const calcRectArea = (width, height) => width * height;\n")),(0,i.kt)("p",null,"Beautiful!"),(0,i.kt)("h4",{id:"functions-conceptually"},"functions, conceptually"),(0,i.kt)("p",null,"In this class, we'll be using ",(0,i.kt)("strong",{parentName:"p"},"arrow functions")," for the most part. They're a bit more concise and are the preferred way to write functions in JavaScript."),(0,i.kt)("p",null,"Conceptually and syntactically, they're simply an anonymous function (an unnamed function (in Java, a lambda expression)) that is assigned to a constant variable. This allows us to utilize all our code in a functional paradigm, with constant and immutable variables that can be both data types like numbers, as well as functions."),(0,i.kt)("p",null,"Yes, just like in every other language, functions can be recursive, and nested."),(0,i.kt)("p",null,"Unlike some other languages, since JavaScript does its best to embrace functional programming, you can also have a function return another function, or be passed into another function as an argument."),(0,i.kt)("h5",{id:"bonus-factory-functions-and-closures"},"bonus: factory functions and closures"),(0,i.kt)("p",null,"Because of this setup, we can use functions to create other functions, which is called a ",(0,i.kt)("strong",{parentName:"p"},"factory function"),". This is a very powerful tool in functional programming, and is used to create ",(0,i.kt)("strong",{parentName:"p"},"closures"),"."),(0,i.kt)("p",null,"A closure is a function that has access to the scope of another function, even after that function has returned. Essentially, you can persist state in a function between calls to a returned function. Crazy, huh?"),(0,i.kt)("p",null,"Here's an example of a factory function that persists state between calls to the returned function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function makeCounter() {\n  let count = 0;\n\n  return function () {\n    return count++;\n  };\n}\n\nconst counter = makeCounter();\n\nconsole.log(counter()); // 0\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\n")),(0,i.kt)("h4",{id:"the-spread-operator-js-specific"},"the spread operator (JS-specific)"),(0,i.kt)("p",null,'The spread operator is a very useful tool in JavaScript. It allows us to "spread" an iterable (such as an array) or an entire object into a new object or array.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const arr = [1, 2, 3];\nconst arr2 = [...arr, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]\n")),(0,i.kt)("p",null,"This, for instance, lets us easily create a new object composed of all the key-value pairs of an existing object, while adding a new key-value pair, and overriding an existing key-value pair."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const obj = { a: 1, b: 2, c: 3 };\nconst obj2 = { ...obj, b: 4, d: 5 }; // { a: 1, b: 4, c: 3, d: 5 }\n")),(0,i.kt)("p",null,"In reverse, we can use the same ",(0,i.kt)("inlineCode",{parentName:"p"},"..."),' syntax to get the "rest" of the elements in an array or object.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const arr = [1, 2, 3, 4, 5];\nconst [first, second, ...rest] = arr; // first = 1, second = 2, rest = [3, 4, 5]\n\nconsole.log(first); // 1\nconsole.log(rest[1]); // 4\n")),(0,i.kt)("h4",{id:"destructuring-js-specific"},"destructuring (JS-specific)"),(0,i.kt)("p",null,"Destructuring is a way to extract data from arrays or objects and assign them to variables automatically, without having to use dot notation or bracket notation to access that data from the array or object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const arr = [1, 2, 3];\nconst [first, second, third] = arr; // first = 1, second = 2, third = 3\n\nconst obj = { a: 1, b: 2, c: 3 };\nconst { a, b, c } = obj; // a = 1, b = 2, c = 3\n")),(0,i.kt)("h4",{id:"string-interpolation-and-template-literals-js-specific"},"String interpolation and template literals (JS-specific)"),(0,i.kt)("p",null,"String interpolation is a way to insert variables into a string. In JavaScript, we can use template literals to do this."),(0,i.kt)("p",null,"This is especially powerful because you can actually insert a full computed Javascript expression into the string, and it will be evaluated and inserted into the string."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const name = 'John';\nconst age = 30;\nconst greeting = `Hello, my name is ${name} and I am ${age + 1} years old.`;\n")),(0,i.kt)("h3",{id:"combining-spreading-and-destructuring"},"combining spreading and destructuring"),(0,i.kt)("p",null,"Say we have a function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const add3 = (a, b, c) => a + b + c;\n")),(0,i.kt)("p",null,"Now if we had an array:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const arr = [1, 2, 3];\n")),(0,i.kt)("p",null,"We can use the ",(0,i.kt)("strong",{parentName:"p"},"spread operator")," ",(0,i.kt)("inlineCode",{parentName:"p"},"...")," to ",(0,i.kt)("em",{parentName:"p"},"destructure")," each element of the\narray as one of the arguments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"add3(...arr); // same as add3(arr[0], arr[1], arr[2]) output 6\n")),(0,i.kt)("p",null,"We can even destruct props as they are passed into a function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const add3 = ({ a, b, c }) => a + b + c;\n")),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Head buzzing already? JavaScript is a super powerful language and this was just a small sample of its language features. Check out Mozilla Developer Network (MDN) for the best JavaScript documentation: ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide"},"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide")))),(0,i.kt)("h2",{id:"typescript"},"TypeScript"),(0,i.kt)("h3",{id:"what-is-typescript"},"What is TypeScript?"),(0,i.kt)("p",null,"TypeScript is a typed ",(0,i.kt)("em",{parentName:"p"},"superset")," of JavaScript that compiles to plain JavaScript (actually, all the types will disappear on compilation!). Superset means TypeScript has everything in JavaScript and more. (Built by Microsoft back in 2012, so now it's a little over a decade old!)"),(0,i.kt)("h3",{id:"typescript-conceptually"},"TypeScript, conceptually."),(0,i.kt)("p",null,"TypeScript was created to solve the problem of JavaScript's weak typing. To do this, while still preserving the power that JavaScript's weak typing gives us, TypeScript adds complex type calculations to JavaScript using the fundamentals of set and type theory."),(0,i.kt)("p",null,"For instance, you have intersections, unions, and generics. These are all concepts that are used in TypeScript to make it a typed language."),(0,i.kt)("p",null,"Additionally, to prevent you from having to manually type out types for every variable, function, and object, TypeScript has a type inference engine that can infer types for you. For instance, if you have a variable ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," that is assigned to the number ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),", TypeScript will infer that ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is a number."),(0,i.kt)("h3",{id:"typescript-types"},"TypeScript Types"),(0,i.kt)("p",null,"TypeScript has 6 primitive types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Boolean"),(0,i.kt)("li",{parentName:"ul"},"String"),(0,i.kt)("li",{parentName:"ul"},"Number"),(0,i.kt)("li",{parentName:"ul"},"Symbol"),(0,i.kt)("li",{parentName:"ul"},"undefined"),(0,i.kt)("li",{parentName:"ul"},"BigInt")),(0,i.kt)("p",null,"All TypeScript values are those 6 primitive types, or an:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"object"),(0,i.kt)("li",{parentName:"ul"},"function (JavaScript is functional!)"),(0,i.kt)("li",{parentName:"ul"},"null")),(0,i.kt)("h3",{id:"how-are-types-used"},"How are types used?"),(0,i.kt)("p",null,"In JavaScript we had:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let str = 'Hello, trends';\nlet num = 42;\nlet truth = true;\n\nconst someFunc = (x, s, b) => {\n  // do some operations...\n  return x;\n};\n")),(0,i.kt)("p",null,"Notice we don't have any types here! JavaScript is ",(0,i.kt)("strong",{parentName:"p"},"weakly typed"),", meaning\nthat it is lenient with declaring what types variables are before you\nrun a program with them, similarly to Python."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let str: string = 'Hello, trends';\nlet num: number = 42;\nlet truth: boolean = false;\nconst someFunc = (x: number, s: string, b: boolean): number => {\n  // do some operations...\n  return x;\n};\n")),(0,i.kt)("p",null,"TypeScript allows us to add type information! We can add types to variables, functions, and objects, using the colon ",(0,i.kt)("inlineCode",{parentName:"p"},":")," syntax. This is called ",(0,i.kt)("strong",{parentName:"p"},"strong typing"),", and it prevents us from assigning the wrong type to a variable."),(0,i.kt)("h3",{id:"why-typescript"},"Why TypeScript?"),(0,i.kt)("p",null,"JavaScript code can be ambiguous. We had the function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const someFunc = (x, s, b) => {\n  // do some operations...\n  return x;\n};\n")),(0,i.kt)("p",null,"What are ",(0,i.kt)("inlineCode",{parentName:"p"},"x, s, b"),"? What should I pass in for those? What should I expect returned?"),(0,i.kt)("p",null,"Adding the TypeScript types makes this code self-documenting:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const someFunc = (x: number, s: string, b: boolean): number => {\n  // do some operations...\n  return x;\n};\n")),(0,i.kt)("p",null,"JavaScript variables can also change type which can be undesirable, unexpected, and error-prone."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let str = 'Hello, trends';\nlet num = 42;\nlet truth = true;\nstr = 13;\n")),(0,i.kt)("p",null,"None of these variables have to be any specific type! I can have ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," be a string and then a number."),(0,i.kt)("p",null,"In the end, we want to use TypeScript because it is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Easier to read"),(0,i.kt)("li",{parentName:"ul"},"Easier and faster to implement"),(0,i.kt)("li",{parentName:"ul"},"Easier to refactor"),(0,i.kt)("li",{parentName:"ul"},"Less buggy")),(0,i.kt)("h3",{id:"typescript-types-1"},"TypeScript Types"),(0,i.kt)("p",null,"Basic Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let <var_name>: <type> = <something>;\n")),(0,i.kt)("p",null,"We can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," but again no ",(0,i.kt)("inlineCode",{parentName:"p"},"var"),"."),(0,i.kt)("h4",{id:"basic-types"},"Basic Types"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Boolean\nlet isDone: boolean = false;\n// Number can be decimal, or in any base!\nlet decimal: number = 4.2;\nlet binary: number = 0b1010;\nlet hex: number = 0xf00d;\n// String\nlet lang: string = 'typescript';\nlet templateStr: string = `We love ${lang}`;\n// Boolean\nlet isDone: boolean = false;\n// Number can be decimal, or in any base!\nlet decimal: number = 4.2;\nlet binary: number = 0b1010;\nlet hex: number = 0xf00d;\n// String\nlet lang: string = 'typescript';\nlet templateStr: string = `We love ${lang}`;\n")),(0,i.kt)("p",null,"Besides the basic types, TypeScript also has 4 more ambiguous types:"),(0,i.kt)("h4",{id:"any"},"Any"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"any")," is a wildcard and it can be anything. ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," places no restrictions on type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Any: can be anything!\nlet notSure: any = 4;\nnotSure = 'maybe a string instead';\nnotSure = false; // now its a boolean\n")),(0,i.kt)("p",null,"If you were to use ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," everywhere though you might as well just use JavaScript."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let anyList: any[] = [4, 'le string', false];\n")),(0,i.kt)("p",null,"But it can be useful in specifying collections of items of different types, when\nyou don't know the constituent types. If you did know that they could either\nbe numbers, strings, or booleans as the above code snippet, you could have written:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let hodgePodgeList: (number | string | boolean)[] = [4, 'le string', false];\n")),(0,i.kt)("h3",{id:"unknown"},"Unknown"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"unknown")," is similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," but it is more restrictive. ",(0,i.kt)("inlineCode",{parentName:"p"},"unknown")," is a type-safe ",(0,i.kt)("inlineCode",{parentName:"p"},"any"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let notSure: unknown = 4;\nnotSure = 'maybe a string instead';\nnotSure = false; // okay, definitely a boolean\n")),(0,i.kt)("p",null,"We use this type when we don't know the type of a variable but we want to make sure we check the type before using it. It allows us to broadly define a type which we don't know, and then later programmatically check the type and narrow it down, either via a type guard or type assertion."),(0,i.kt)("p",null,"An example of a type guard is ",(0,i.kt)("inlineCode",{parentName:"p"},"typeof"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let notSure: unknown = 4;\nif (typeof notSure === 'string') {\n  // TypeScript knows notSure is a string\n  notSure.toUpperCase();\n}\n")),(0,i.kt)("p",null,"Type assertions are a way to tell TypeScript that we know better than it does what the type of a variable is. We can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," keyword:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let notSure: unknown = 4;\n// TypeScript knows notSure is a number\n(notSure as number).toFixed();\n")),(0,i.kt)("h4",{id:"never"},"Never"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"never")," is the type of values that never occur. For instance, a function that always throws an exception or one that never returns. Variables also acquire the type ",(0,i.kt)("inlineCode",{parentName:"p"},"never")," when narrowed by any type guards that can never be true."),(0,i.kt)("p",null,"In set theory, think of it as the empty set - when you take the intersection of two sets that have no elements in common, you get the empty set."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const error = (message: string): never => {\n  throw new Error(message);\n};\n\nconst infiniteLoop = (): never => {\n  while (true) {}\n};\n")),(0,i.kt)("p",null,"You can think of it as the opposite of ",(0,i.kt)("inlineCode",{parentName:"p"},"void"),", which is the absence of having any type at all."),(0,i.kt)("h4",{id:"void"},"Void"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"void")," is the absence of having any type at all. You may see this as the return type of functions that do not return a value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const warnUser = (): void => {\n  console.log('This is my warning message');\n};\n")),(0,i.kt)("p",null,"Back to less ambiguous types! We can type functions and more."),(0,i.kt)("h4",{id:"functions"},"Functions"),(0,i.kt)("p",null,"Here's how we can type functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// un-typed\nconst myFunc = (x, y) => x + y;\n// typed\nconst myFunc = (x: number, y: number): number => x + y;\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"myFunc")," has type ",(0,i.kt)("inlineCode",{parentName:"p"},"(x: number, y: number): number"),"."),(0,i.kt)("p",null,"TypeScript can do some limited type inference so if you leave out the return type ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", TypeScript can infer it since we are just adding two numbers which can only produce a number. If TypeScript can't infer the type, it defaults as ",(0,i.kt)("inlineCode",{parentName:"p"},"any"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Optional or Possibly-Undefined Types (?)")),(0,i.kt)("p",null,"We can also have optional parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const introduce = (name: string, github?: string): string => {\n  return github\n    ? `Hi, I'm ${name}. Checkout my GitHub @${github}`\n    : `Hi, I'm ${name}. I don't have a GitHub.`;\n};\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"github?")," designates ",(0,i.kt)("inlineCode",{parentName:"p"},"github")," as an optional parameter that defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),".\nEssentially, you can think of ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," as syntactic sugar for ",(0,i.kt)("inlineCode",{parentName:"p"},"| undefined"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Default Parameters")),(0,i.kt)("p",null,"We can also have default parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const introduce = (name: string, github: string = 'no-github'): string => {\n  return github\n    ? `Hi, I'm ${name}. Checkout my GitHub @${github}`\n    : `Hi, I'm ${name}. I don't have a GitHub.`;\n};\n")),(0,i.kt)("p",null,"This is a just an optional parameter with a default value."),(0,i.kt)("h4",{id:"literal-types"},"Literal Types"),(0,i.kt)("p",null,"Literal Types are types that can be a literal set of possibilities that you specify. TypeScript allows number and string literal types:"),(0,i.kt)("h5",{id:"string-literal-types"},"String Literal Types"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// String literal type\ntype TrafficLightColors = 'red' | 'green' | 'yellow';\n")),(0,i.kt)("p",null,"Any variable with ",(0,i.kt)("inlineCode",{parentName:"p"},"TrafficLightColors")," type can only take on values ",(0,i.kt)("inlineCode",{parentName:"p"},'"red", "green", "yellow"'),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let light1: TrafficLightColors = 'red';\nlight1 = 'blue'; // TypeError\n")),(0,i.kt)("h5",{id:"numeric-literal-types"},"Numeric Literal Types"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Numeric literal type\ntype DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;\nconst rollDice = (): DiceRoll => {\n  // ...\n  return 7; // TypeError\n};\n")),(0,i.kt)("h4",{id:"union-types"},"Union Types"),(0,i.kt)("p",null,"With union types, a variable can be of one type or another type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const union: number | string = 5; // number\nconst union2: number | string = 'hello'; // string\n\ntype TrafficLightColors = 'red' | 'green' | 'yellow';\ntype PrimaryColors = 'red' | 'green' | 'blue';\n\n// \"red\" | \"green\" | \"yellow\" | \"blue\"\ntype union = PrimaryColors | TrafficLightColors;\n")),(0,i.kt)("h4",{id:"intersection-types"},"Intersection Types"),(0,i.kt)("p",null,"With union types, a variable must be of one type and another type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Intersection Type\ntype TrafficLightColors = 'red' | 'green' | 'yellow';\ntype PrimaryColors = 'red' | 'green' | 'blue';\ntype intersect = PrimaryColors & TrafficLightColors; // \"red\" | \"green\"\n")),(0,i.kt)("h4",{id:"enumerations"},"Enumerations"),(0,i.kt)("p",null,"Enumerations are a way to give more friendly names to key-value pair sets of pre-determined values."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"enum TrafficLightColors {\n  Red = 'red',\n  Green = 'green',\n  Yellow = 'yellow',\n}\n")),(0,i.kt)("p",null,"The values of the enum are the strings ",(0,i.kt)("inlineCode",{parentName:"p"},"'red', 'green', 'yellow'"),". The names of the enum are the keys ",(0,i.kt)("inlineCode",{parentName:"p"},"Red, Green, Yellow"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let light1: TrafficLightColors = TrafficLightColors.Red;\nlight1 = TrafficLightColors.Blue; // TypeError\n")),(0,i.kt)("p",null,"Note how, since an Enumeration is a type, we can use it to type variables and prevent them from being any value other than the ones specified in the enum."),(0,i.kt)("h4",{id:"interfaces"},"Interfaces"),(0,i.kt)("p",null,"Interfaces are a way to describe the structure of an object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface Person {\n  name: string;\n  age: number;\n  isAlive: boolean;\n}\n")),(0,i.kt)("p",null,"We can use interfaces to type object variables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let person1: Person = {\n  name: 'John',\n  age: 30,\n  isAlive: true,\n};\n")),(0,i.kt)("p",null,"We can also use interfaces to describe function parameters and return types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface Person {\n  name: string;\n  age: number;\n  isAlive: boolean;\n}\n\ninterface PersonIntroduction {\n  introduction: string;\n  isAlive: boolean;\n}\n\nconst introduce = (person: Person): PersonIntroduction => {\n  return {\n    introduction: `Hi, I'm ${person.name}. I'm ${person.age} years old.`,\n    isAlive: person.isAlive,\n  };\n};\n")),(0,i.kt)("h5",{id:"bonus-content-complex-interface-usage"},"Bonus Content: Complex Interface Usage"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"We can enforce the type of an unlimited number of children key-value pairs.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface Person {\n  name: string;\n  age: number;\n  isAlive: boolean;\n  [key: string]: number | string | boolean;\n}\n")),(0,i.kt)("p",null,"Now, we can add any number of key-value pairs to ",(0,i.kt)("inlineCode",{parentName:"p"},"Person"),", keyed by string, with values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"number | string | boolean"),"."),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"We can extend other, existing interfaces.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface Person {\n  name: string;\n  age: number;\n  isAlive: boolean;\n}\n\ninterface PersonIntroduction {\n  introduction: string;\n  isAlive: boolean;\n}\n\ninterface PersonWithIntroduction extends Person, PersonIntroduction {}\n")),(0,i.kt)("p",null,"Here, PersonWithIntroduction contains the keys: ",(0,i.kt)("inlineCode",{parentName:"p"},"name, age, isAlive, introduction"),"."),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"We can reopen interfaces to add new keys.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface Person {\n  name: string;\n  age: number;\n  isAlive: boolean;\n}\n\ninterface PersonIntroduction {\n  introduction: string;\n  isAlive: boolean;\n}\n\ninterface PersonWithIntroduction extends Person, PersonIntroduction {}\n\ninterface PersonWithIntroduction {\n  favoriteColor: string;\n}\n")),(0,i.kt)("p",null,"Here, PersonWithIntroduction contains the keys: ",(0,i.kt)("inlineCode",{parentName:"p"},"name, age, isAlive, introduction, favoriteColor"),"."),(0,i.kt)("p",null,'This is because we "reopened" PersonWithIntroduction to add a new key, and this now redefines PersonWithIntroduction.'),(0,i.kt)("h4",{id:"type-assertions"},"Type Assertions"),(0,i.kt)("p",null,"Type assertions are a way to tell TypeScript that you know better than it does. This is useful when you know that a variable is of a certain type but TypeScript doesn't."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const myString = 'hello';\nconst myStringLen = (myString as string).length;\n")),(0,i.kt)("p",null,"Here, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," keyword to tell TypeScript that ",(0,i.kt)("inlineCode",{parentName:"p"},"myString")," is a string."),(0,i.kt)("p",null,"Additionally, we have a shorthand for asserting something isn't ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const myString = 'hello';\nconst myStringLen = myString!.length;\n")),(0,i.kt)("p",null,"Here, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," operator to tell TypeScript that ",(0,i.kt)("inlineCode",{parentName:"p"},"myString")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," (note how it's the opposite of the ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," operator)."),(0,i.kt)("h4",{id:"generics"},"Generics"),(0,i.kt)("p",null,"Generics are a way to make a function more flexible. They allow you to specify a type parameter that can be used in the function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const introduce = <T>(name: T): string => {\n  return `Hi, I'm ${name}.`;\n};\n")),(0,i.kt)("p",null,"Here, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"<T>")," syntax to specify that ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," can be of any type. We can then use ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," in the function body."),(0,i.kt)("p",null,"Generics can get pretty complex. For instance, we can enforce that the generic type extends a certain type, and then access that type's properties:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const introduce = <T extends { name: string }>(person: T): string => {\n  return `Hi, I'm ${person.name}.`;\n};\n")),(0,i.kt)("p",null,"In the example above, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," keyword to specify that ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," must extend the type ",(0,i.kt)("inlineCode",{parentName:"p"},"{ name: string }"),". This means that ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," must have a ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," property that is a string. We can then access ",(0,i.kt)("inlineCode",{parentName:"p"},"person.name")," in the function body, even when we have no idea what type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," actually is."),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"There's also so much more to TypeScript. Check out the TypeScript docs to learn more! ",(0,i.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/"},"https://www.typescriptlang.org/docs/")))),(0,i.kt)("p",null,"Now that we know the basics of JS and TS, we can really start leveraging the power of functional programming within these paradigms. Here's a quick overview of some of the functional programming patterns you'll use in this course."),(0,i.kt)("h2",{id:"functional-programming"},"Functional Programming"),(0,i.kt)("h3",{id:"control-branching"},"Control Branching:"),(0,i.kt)("p",null,"Unfortunately, JavaScript only has one control statement available in a declarative manner: the ternary operator. This is a very limited way to control branching, and it's not very readable. In essence, it looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"condition ? trueValue : falseValue; // this expression evaluates to trueValue if condition is true, and falseValue otherwise\n")),(0,i.kt)("p",null,"Note how this contrasts to a traditional if-else statement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'if (condition) {\n  return trueValue;\n} else {\n  return falseValue;\n}\n// this isn\'t an evaluated expression (thus, "declarative") -- it\'s an executed series of commands (thus, "imperative")\n')),(0,i.kt)("p",null,"With nested ternary operators, we can take care of many possible cases with surprisingly clean-looking code (though we're still hoping the JavaScript community will add more declarative control branching statements):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"condition1\n  ? trueValue1\n  : condition2\n  ? trueValue2\n  : condition3\n  ? trueValue3\n  : falseValue;\n")),(0,i.kt)("p",null,"Some syntactic sugar operators include ",(0,i.kt)("inlineCode",{parentName:"p"},"??")," (nullish coalescing) and ",(0,i.kt)("inlineCode",{parentName:"p"},"||")," (logical OR). These operators are used to assign a value to a variable if the variable is nullish or falsy, respectively. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let x = null;\nx ??= 5; // x is now 5\nx ||= 10; // x is still 5\n")),(0,i.kt)("h3",{id:"functions-1"},"Functions:"),(0,i.kt)("p",null,"Conceptually, you'll note all of the following are functions that act and originate from a single data source."),(0,i.kt)("h3",{id:"map"},(0,i.kt)("inlineCode",{parentName:"h3"},"map")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"array.map(function)")," runs ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," on each element of ",(0,i.kt)("inlineCode",{parentName:"p"},"array"),"\xa0and returns\nan array containing the results."),(0,i.kt)("p",null,"Example: ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 4, 9].map(x => Math.sqrt(x))")," will return ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 2, 3]"),"."),(0,i.kt)("h3",{id:"filter"},(0,i.kt)("inlineCode",{parentName:"h3"},"filter")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"array.filter(function)")," runs ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," on each element of ",(0,i.kt)("inlineCode",{parentName:"p"},"array"),"\xa0and return\nan array containing all elements that satisfy the function requirements."),(0,i.kt)("p",null,"Example: ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 4, 9].filter(x => x > 3)")," will return ",(0,i.kt)("inlineCode",{parentName:"p"},"[4, 9]")),(0,i.kt)("h3",{id:"foreach"},(0,i.kt)("inlineCode",{parentName:"h3"},"forEach")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"array.forEach(function)")," runs ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," on each element of ",(0,i.kt)("inlineCode",{parentName:"p"},"array"),".\nThe difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"forEach")," is that map returns a value, whereas\nforEach just applies the function to each element of the array."),(0,i.kt)("p",null,"Example: ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 4, 9].forEach(x => console.log(x))")," will print out each element\nto the console."),(0,i.kt)("h3",{id:"every"},(0,i.kt)("inlineCode",{parentName:"h3"},"every")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"array.every(function)")," runs ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," on each element of ",(0,i.kt)("inlineCode",{parentName:"p"},"array")," and returns\nwhether every element of the array satisfies the function requirements."),(0,i.kt)("p",null,"Example: ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 4, 9].every(x => x > 0)")," will return true. However,\n",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 4, 9].every(x => x > 1)")," will return false."),(0,i.kt)("h3",{id:"some"},(0,i.kt)("inlineCode",{parentName:"h3"},"some")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"array.some(function)")," runs ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," on each element of ",(0,i.kt)("inlineCode",{parentName:"p"},"array")," and returns\nwhether any element of the array satisfies the function requirements."),(0,i.kt)("p",null,"Example: ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 4, 9].some(x => x == 1)")," will return true. However,\n",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 4, 9].some(x => x == 2)")," will return false."),(0,i.kt)("h3",{id:"reduce"},(0,i.kt)("inlineCode",{parentName:"h3"},"reduce")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"array.reduce(function)")," runs ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," on each element of ",(0,i.kt)("inlineCode",{parentName:"p"},"array"),"\xa0and returns\na single value."),(0,i.kt)("p",null,"Example: ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 4, 9].reduce((sum, curr) => sum + curr)")," will return 14."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"reduce")," can take an optional second parameter to change the value that the\naccumulator starts at."),(0,i.kt)("p",null,"Example: ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 4, 9].reduce((sum, curr) => sum + curr, 500)")," will return 514."),(0,i.kt)("h2",{id:"ugly-pieces-of-javascript"},"Ugly Pieces of JavaScript"),(0,i.kt)("p",null,"Yes, JavaScript has a bad rep, and for good reason. Here are some of the most\negregious parts of JavaScript -- the stuff that'll probably trip you up at some point."),(0,i.kt)("h3",{id:"truthy-falsy"},"Truthy, falsy"),(0,i.kt)("p",null,"JavaScript values can be classified into 'truthy' and 'falsy'. Of course, ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"\nis truthy and false is ",(0,i.kt)("inlineCode",{parentName:"p"},"falsy"),". Most values are truthy, except:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"false")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"''")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"{}")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"undefined")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NaN"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," guard in JavaScript checks whether a value is truthy rather than\nwhether the value is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". Similar mechanism applies to ",(0,i.kt)("inlineCode",{parentName:"p"},"&&")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"||"),".\nTherefore, we have"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'' && 'haha'")," evaluates to ",(0,i.kt)("inlineCode",{parentName:"li"},"''")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'haha' || ''")," evaluates to ",(0,i.kt)("inlineCode",{parentName:"li"},"'haha'"),".")),(0,i.kt)("h3",{id:"global-variables"},"Global variables"),(0,i.kt)("p",null,"You were told because that there are only one way to define a variable before\nES6: ",(0,i.kt)("inlineCode",{parentName:"p"},"var"),". This is a white lie. You can actually define a variable without\n",(0,i.kt)("inlineCode",{parentName:"p"},"var"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"let"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"const"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"foo = 3;\n")),(0,i.kt)("p",null,"If you do this, then you just define a ",(0,i.kt)("strong",{parentName:"p"},"global variable"),". It means you can use\nthe variable ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," everywhere. If you have a local variable, then you might\naccidentally use or override it with the wrong value."),(0,i.kt)("p",null,"Lessons learned: never use or define global variables."),(0,i.kt)("h3",{id:"type-coercion"},"Type coercion"),(0,i.kt)("p",null,"Like most languages, JavaScript coerces types to better suit the operations\nthat are being applied."),(0,i.kt)("h4",{id:"example-1"},"Example 1"),(0,i.kt)("p",null,"If we execute ",(0,i.kt)("inlineCode",{parentName:"p"},"true + false")," we get 1. This is because there is an\naddition operator, and ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," gets coerced to 1 while ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"\xa0gets coerced to 0."),(0,i.kt)("h4",{id:"example-2"},"Example 2"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"{} + [] + {} + [1]")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"0[object Object]1")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"{} + []"),"\ngets evaluated to 0, ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," gets evaluated to ","[object Object]",", and they both get\ncoerced to strings. Then, adding a list to a string simply adds the contents of\nthe list to the string, so 1 gets appended to the end."),(0,i.kt)("h4",{id:"example-3"},"Example 3"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const zero = +[]; // + coerce [] into 0\nconst one = +!![]; // ! coerce [] into false, got inverted, then coerce to 1\nconst two = +!![] + +!![]; // 2 = 1 + 1\n\nconst fib2 = (__) =>\n  __ === zero || __ === one ? __ : fib2(__ - one) + fib2(__ - two);\n")),(0,i.kt)("p",null,"This is the Fibonacci sequence implemented using type coercion."),(0,i.kt)("h3",{id:"in-class-demo-1-types"},"In-class Demo 1: Types!"),(0,i.kt)("p",null,"TODO: @daniel"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pre-assessment solutions, but walk them through it and use types")))}d.isMDXComponent=!0}}]);